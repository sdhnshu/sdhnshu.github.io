<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Sudhanshu Passi - Asynchronous Python App Architecture</title><meta name=description content="Sudhanshu Passi's personal website"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><link rel=stylesheet href=https://www.sdhnshu.com/css/bootstrap.min.css><link href="https://fonts.googleapis.com/css2?family=Lato&family=Merriweather:wght@300&display=swap" rel=stylesheet><link rel=stylesheet href=https://www.sdhnshu.com/css/font-awesome.min.css><link rel=stylesheet href=https://www.sdhnshu.com/css/owl.carousel.css><link rel=stylesheet href=https://www.sdhnshu.com/css/owl.theme.css><link href=https://www.sdhnshu.com/css/style.violet.css rel=stylesheet id=theme-stylesheet><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script><script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><link rel=stylesheet href=//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/atom-one-dark.min.css><script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js></script><script>hljs.initHighlightingOnLoad();</script><link href=https://www.sdhnshu.com/css/custom.css rel=stylesheet><link rel="shortcut icon" href=https://www.sdhnshu.com/img/favicon.ico><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-173272544-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body><div id=all><div class=container-fluid><div class="row row-offcanvas row-offcanvas-left"><div id=sidebar class="col-xs-6 col-sm-4 col-md-3 sidebar-offcanvas"><div class=sidebar-content><h1 class=sidebar-heading><a href=https://www.sdhnshu.com/>Sudhanshu Passi</a></h1><ul class=sidebar-menu><li><a href=https://www.sdhnshu.com/showcase/>Showcase</a></li><li><a href=https://www.sdhnshu.com/experiments/>Experiments</a></li><li><a href=https://www.sdhnshu.com/about/>About</a></li></ul><p class=social><a href=https://github.com/sdhnshu data-animate-hover=pulse class=external><i class="fa fa-github"></i></a><a href=mailto:sudhanshupassi@gmail.com data-animate-hover=pulse class=email><i class="fa fa-envelope"></i></a><a href=https://www.linkedin.com/in/sdhnshu/ data-animate-hover=pulse class=external><i class="fa fa-linkedin"></i></a><a href=https://twitter.com/Sudhanshupassi data-animate-hover=pulse class="external twitter"><i class="fa fa-twitter"></i></a><a href=https://medium.com/@sdhnshu data-animate-hover=pulse class=external><i class="fa fa-medium"></i></a></p><div class=copyright><p class=credit>&copy; 2020 Sudhanshu Passi</p></div></div></div><div class="col-xs-12 col-sm-8 col-md-9 content-column white-background"><div class="small-navbar visible-xs"><button type=button data-toggle=offcanvas class="btn btn-ghost pull-left"> <i class="fa fa-align-left"></i>Menu</button><h1 class=small-navbar-heading><a href=https://www.sdhnshu.com/>Sudhanshu Passi</a></h1></div><div class=row><div class=col-lg-11><div class=content-column-content><h1>Asynchronous Python App Architecture</h1><i><p class=timestamp>Last updated Jul 30, 2018</p></i><p>Learn how to choose the correct architecture for your application.</p><p><img src=https://miro.medium.com/max/700/0*y_3JGr5VRvkcAcjE.png alt=img></p><ul><li>Originally published on <a href=https://medium.com/cowrks/asynchronous-python-app-architecture-5395d5338c4a>Medium</a></li></ul><h3 id=introduction>Introduction</h3><p>Choosing an application architecture greatly depends on the scale you are building it for.</p><blockquote><p>1x Monolith</p><p>10x Micro service</p><p>100x Asynchronous Micro service</p><p>1000x Distributed</p></blockquote><p>In this post, we’ll be deep-diving into how to build an asynchronous python api with async db connections.</p><p>We’ll be using sanic (v0.7) as the api framework and asyncpg (v0.15) to connect to a postgres db. You can use any async db framework you prefer.</p><hr><h3 id=how-we-use-async>How we use async?</h3><p>We started using sanic after we had experimented with various other api frameworks like falcon, flask, tornado and twisted. In a few months, python added asyncio to its framework. Libraries started popping up using this async feature. We found this framework when it had around 500 stars on github. And the community grew so fast and at the time of this writing it has shot up to over 10k stars. We started using it on our production servers and have yet to encounter any serious issues.</p><p>Due to that switch, we had to use async db frameworks, async file readers, async requests package and many more async packages. We have started building async libraries for our apps and are quite satisfied by the performance.</p><hr><h3 id=is-python-purely-asynchronous>Is python purely asynchronous?</h3><p>No. The most that we can get with python is context switching between different tasks so that the thread is being used to its optimum processing capacity. (Don’t worry if you didn’t get this, we’ll come back to this later.)</p><hr><h3 id=how-does-async-in-python-work>How does async in python work?</h3><p>The concept of asynchronous programming was introduced into python 3.4. It was introduced very late due to a fundamental python concept — Global Interpreter Lock (GIL) which blocked it from being asynchronous. If you do want to elevate the api scale to a massive level, you might have to resort to some other approach for instance having a distributed cluster, building an api that supports pure async eg: c, cpp.</p><p>Almost all asynchronous python frameworks use python’s standard library: asyncio underneath. All of these async libraries have similar architectures.</p><h4 id=event-loop>Event loop</h4><p>The central part of async is an event loop. As the name suggests, it is a loop. One python event loop runs on one OS thread. So only one calculation will be executed by the processor at a time. You can add tasks to this loop and it executes them on a FIFO fashion. So it’s really important that your tasks have a trigger (more about it later) that passes the control back to the loop when it is doing an input/output function that does not require processing power. This transfer of control is the central theme of any async framework. Once the control is back at the loop, it can execute the other tasks in the loop.</p><p>Here’s how you can create an event loop using asyncio:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>loop <span style=color:#f92672>=</span> asyncio<span style=color:#f92672>.</span>get_event_loop()
loop<span style=color:#f92672>.</span>run_until_complete(tasks())
</code></pre></div><p>The command in the second line is directing the loop to run until all the tasks are complete. The above function tasks is an async function. We’ll explain how to define an async function later on.</p><p>The loop controls what task gets executed when, and does the context switching between different tasks.</p><h4 id=defining-async-functions>Defining async functions</h4><p>Here’s the syntax of async function:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>async <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>function_name</span>():
    resp <span style=color:#f92672>=</span> await some_other_async_function()
    <span style=color:#66d9ef>return</span> resp
</code></pre></div><p>This function is added to an event loop to be executed as a task.</p><p>Here you can see two new things async and await. Async means the function is asynchronous. When the interpreter reaches the Await part, it passes the control back to the event loop (the trigger) and waits for some_other_async_function to complete. some_other_async_function is a function that doesn’t require computation, it can be a input/output operation like a db fetch or a db input. So while that db query is being executed, other tasks in the event loop can be executed. And when the response comes back from the db function, it goes back to the resp variable and is returned.</p><p>So there’s nothing special about this function except that it can pause itself and give others the time to execute. It doesn’t block the thread when not needed.</p><p>So an async function can call another async function; it can also call a sync function. But remember that it will block the thread till it completes so it must be using some computation. Also every async function will be awaited by the one who called it.</p><hr><h3 id=sanic>Sanic</h3><p>Sanic is a api framework that uses <a href=https://magic.io/blog/uvloop-blazing-fast-python-networking/>uvloop</a> as its event loop. Uvloop is what makes sanic blazingly fast. Its around <strong>2x faster than any nodejs</strong> async server. Almost <strong>5x faster than tornado or twisted</strong> (python api frameworks) and has half the latency of any other servers (and is obviously around 10x faster than any sync api framework like falcon, flask, django). Uvloop is written in Cython and is built on top of a asynchronous library written in C.</p><p>Let’s check out an example:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>app <span style=color:#f92672>=</span> sanic<span style=color:#f92672>.</span>Sanic()app<span style=color:#f92672>.</span>add_route(root_func, <span style=color:#e6db74>&#39;/&#39;</span>, methods<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#39;GET&#39;</span>])
app<span style=color:#f92672>.</span>add_route(users_func, <span style=color:#e6db74>&#39;/users/&lt;uid&gt;&#39;</span>, methods<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#39;GET&#39;</span>])<span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;__main__&#34;</span>:
    app<span style=color:#f92672>.</span>run(host<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;0.0.0.0&#34;</span>, port<span style=color:#f92672>=</span><span style=color:#ae81ff>8000</span>, workers<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>)
</code></pre></div><p>Here, <code>root_func</code>, <code>users_func</code> are async functions.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>async <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>root_func</span>(request):
    resp <span style=color:#f92672>=</span> await do_whatever()
    <span style=color:#66d9ef>return</span> sanic<span style=color:#f92672>.</span>response<span style=color:#f92672>.</span>json({<span style=color:#e6db74>&#39;resp&#39;</span>: resp})async <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>users_func</span>(request, uid):
    resp <span style=color:#f92672>=</span> await do_whatever()
    <span style=color:#66d9ef>return</span> sanic<span style=color:#f92672>.</span>response<span style=color:#f92672>.</span>json({<span style=color:#e6db74>&#39;resp&#39;</span>: resp})
</code></pre></div><p>In a sync api framework, the app can take only one request at a time, process it completely and then move on to other requests. And if that process is an i/o operation and takes a lot of time, the app will be stuck till it is completed. But here, it can be awaited and the app can work on other requests while the i/o operation returns a response.</p><p>Hence we are not executing things in parallel, just switching between tasks when free.</p><p>To add some more speed to the app, we can increase the number of workers while creating the app. But remember, a higher number of workers doesn’t necessarily mean faster speed (processors are also limitedly async.)</p><hr><h3 id=asyncpg>Asyncpg</h3><p>To use asyncpg or any other async library with sanic, we need to perform one more step. Sanic does not use the default asyncio loop underneath. It uses another loop called uvloop which is a faster version of the asyncio loop. So when we define the asyncpg connection, we need to connect that task to the uvloop which is already running instead of creating another event loop and adding tasks to that. In order to do that you need access to the uvloop object. Here’s how you do it:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>app <span style=color:#f92672>=</span> sanic<span style=color:#f92672>.</span>Sanic()

<span style=color:#a6e22e>@app.listener</span>(<span style=color:#e6db74>&#39;before_server_start&#39;</span>)
async <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>before_start</span>(app, uvloop):
    db <span style=color:#f92672>=</span> await asyncpg<span style=color:#f92672>.</span>connect(postgresdb, loop<span style=color:#f92672>=</span>uvloop)

app<span style=color:#f92672>.</span>add_route(root_func, <span style=color:#e6db74>&#39;/&#39;</span>, methods<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#39;GET&#39;</span>])
app<span style=color:#f92672>.</span>add_route(users_func, <span style=color:#e6db74>&#39;/users/&lt;uid&gt;&#39;</span>, methods<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#39;GET&#39;</span>])

<span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;__main__&#34;</span>:
    app<span style=color:#f92672>.</span>run(host<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;0.0.0.0&#34;</span>, port<span style=color:#f92672>=</span><span style=color:#ae81ff>8000</span>, workers<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>)
</code></pre></div><p>Now this db variable can be used with your project and is adding tasks in the uvloop. The function before_start is a sanic special function that gives you access to things before the server has started.</p><hr><h3 id=bonus-points>Bonus points</h3><h4 id=semaphore>Semaphore</h4><p>To avoid the async api from overloading due to a Denial Of Service (DOS) attack, you can add a semaphore to limit the number of simultaneous api requests that are computed by doing the following:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>app <span style=color:#f92672>=</span> sanic<span style=color:#f92672>.</span>Sanic()

<span style=color:#a6e22e>@app.listener</span>(<span style=color:#e6db74>&#39;before_server_start&#39;</span>)
async <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>before_start</span>(app, uvloop):
    sem <span style=color:#f92672>=</span> await asyncio<span style=color:#f92672>.</span>Semaphore(<span style=color:#ae81ff>100</span>, loop<span style=color:#f92672>=</span>uvloop)

app<span style=color:#f92672>.</span>add_route(root_func, <span style=color:#e6db74>&#39;/&#39;</span>, methods<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#39;GET&#39;</span>])
app<span style=color:#f92672>.</span>add_route(users_func, <span style=color:#e6db74>&#39;/users/&lt;uid&gt;&#39;</span>, methods<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#39;GET&#39;</span>])

<span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;__main__&#34;</span>:
    app<span style=color:#f92672>.</span>run(host<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;0.0.0.0&#34;</span>, port<span style=color:#f92672>=</span><span style=color:#ae81ff>8000</span>, workers<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>)

<span style=color:#f92672>-------------------------------------------</span>

async <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>users_func</span>(request, uid):
    async <span style=color:#66d9ef>with</span> sem:
        resp <span style=color:#f92672>=</span> await do_whatever()
        <span style=color:#66d9ef>return</span> sanic<span style=color:#f92672>.</span>response<span style=color:#f92672>.</span>json({<span style=color:#e6db74>&#39;resp&#39;</span>: resp})

async <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>root_func</span>(request):
    async <span style=color:#66d9ef>with</span> sem:
        resp <span style=color:#f92672>=</span> await do_whatever()
        <span style=color:#66d9ef>return</span> sanic<span style=color:#f92672>.</span>response<span style=color:#f92672>.</span>json({<span style=color:#e6db74>&#39;resp&#39;</span>: resp})
</code></pre></div><p>Here I’ve set a semaphore for 100 and attached it to the uvloop. And every api function will be called only when the semaphore lock is open.</p><h4 id=async-classes>Async classes</h4><p>Classes with async functions are defined as:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Class_name</span>:
    <span style=color:#66d9ef>def</span> __init__(self):
        <span style=color:#66d9ef>pass</span>
    async <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>func1</span>(self):
        <span style=color:#66d9ef>pass</span>
    async <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>func2</span>(self):
        <span style=color:#66d9ef>pass</span>
</code></pre></div><p>They are initialized normally but the functions will be awaited because they are async.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>c <span style=color:#f92672>=</span> Class_name()
resp <span style=color:#f92672>=</span> await c<span style=color:#f92672>.</span>func1()
resp <span style=color:#f92672>=</span> await c<span style=color:#f92672>.</span>func2()
</code></pre></div><hr><h3 id=conclusion>Conclusion</h3><p>Asynchronous application architecture is fairly easy to understand and is used widely in all languages especially large scaling apps. It is also a useful tool to have in your arsenal if you are looking towards upgrading your coding game.</p></div></div></div></div></div></div></div><script src=https://www.sdhnshu.com/js/jquery.min.js></script><script src=https://www.sdhnshu.com/js/bootstrap.min.js></script><script src=https://www.sdhnshu.com/js/jquery.cookie.js></script><script src=https://www.sdhnshu.com/js/ekko-lightbox.js></script><script src=https://www.sdhnshu.com/js/jquery.scrollTo.min.js></script><script src=https://www.sdhnshu.com/js/masonry.pkgd.min.js></script><script src=https://www.sdhnshu.com/js/imagesloaded.pkgd.min.js></script><script src=https://www.sdhnshu.com/js/owl.carousel.min.js></script><script src=https://www.sdhnshu.com/js/front.js></script></body></html>